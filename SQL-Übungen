CREATE OR REPLACE PROCEDURE HELLO
IS
BEGIN
DBMS_OUTPUT.PUT_LINE('HELLO WORLD');
END;

EXECUTE HELLO;
SET SERVEROUTPUT ON;


CREATE OR REPLACE PROCEDURE TEXT (

CREATE OR REPLACE PROCEDURE double_num(x IN number, res OUT number)
IS
BEGIN
    res:= x*2;
END;


SET SERVEROUTPUT ON;
DECLARE
result_double integer;
BEGIN
    double_num(100,result_double);
    dbms_output.put_line(result_double);
END;

SET SERVEROUTPUT ON;

CREATE OR REPLACE PROCEDURE transform_name(vorname IN VARCHAR2, vorname_out OUT VARCHAR2, nachname IN VARCHAR2, nachname_out OUT VARCHAR2)
IS
BEGIN
vorname_out := UPPER(vorname);
nachname_out := UPPER(nachname);
END;

DECLARE
a VARCHAR2(20);
b VARCHAR2(20);
BEGIN
transform_name('noel',a,'kÃ¶roglu',b);
dbms_output.put_line(a);
dbms_output.put_line(b);
END;
-------------------------------------------------------------------------------------------------------------
ALTER SESSION SET CURRENT_SCHEMA = FAHRRAD;


--%alle zeichen danach sind egal



--AUFGABE a)
SELECT Vorname FROM kunden
WHERE Vorname LIKE ('Ha%') OR Vorname LIKE ('HA%') OR Vorname LIKE ('ha%');



--AUFGABE b)
SELECT Rechnungsdatum, Lieferdatum 
FROM Auftraege
    WHERE Rechnungsdatum <= Lieferdatum;
    
    



--AUFGABE c)
SELECT abt.Name, an.Geschlecht,
COUNT ( CASE WHEN geschlecht='w' then 1 end) as Anzahl_Angestellte_Weiblich,
COUNT ( CASE WHEN geschlecht='m' then 1 end) as Anzahl_Angestellte_MÃ¤nnlich
FROM Angestellte an
JOIN Abteilungen abt ON an.abt_nr = abt.abt_nr
GROUP BY abt.name, an.geschlecht
ORDER BY abt.name;






--AUFGABE d)
WITH auftragsanzahl AS
(SELECT DISTINCT COUNT(*) OVER(PARTITION BY k.kun_nr) AS auftrags_anzahl
 FROM Auftraege a
 JOIN Kunden k ON a.kun_nr = k.kun_nr
 GROUP BY k.kun_nr, a.auftragsnr)
 ,
 ausgabe AS
 (SELECT DISTINCT k.vorname, k.nachname
 FROM Auftraege a
JOIN Kunden k ON a.kun_nr = k.kun_nr
 GROUP BY k.kun_nr, k.vorname, k.nachname, a.auftragsnr)
 , alles AS
 (SELECT DISTINCT vorname, nachname FROM ausgabe)
 , alles2 AS
 (SELECT DISTINCT auftrags_anzahl FROM auftragsanzahl WHERE auftrags_anzahl>=3)
 , alles3 AS
(SELECT * FROM alles, alles2)
SELECT * FROM alles3
 ORDER BY Vorname;

 
 
 SELECT k.kun_nr, k.vorname, k.nachname, COUNT(*) OVER(PARTITION BY k.kun_nr) AS auftrags_anzahl
 FROM Auftraege a
 JOIN Kunden k ON a.kun_nr = k.kun_nr
 GROUP BY k.kun_nr, k.vorname, k.nachname, a.auftragsnr;

 -------------------------------------------------------------------------------------------------------------------------
LÃ¶sungen:

-- 
-- DBS-1: LÃ¶sung WS2021/22
--
-- 3. Praktikum 
-- Skript fÃ¼r Aufgabe 1
--  
-- ERD PGMperfect  
-- 
-- Autor: Birgit Bertelsmeier vom 28.11.2017 
-- --------------------------------------------
-- 
-- Aufgabe 1) 
--  
-- 
DROP TABLE Studenten CASCADE CONSTRAINTS; 
DROP TABLE Personal  CASCADE CONSTRAINTS; 
DROP TABLE Projekte  CASCADE CONSTRAINTS; 
DROP TABLE Gruppen CASCADE CONSTRAINTS; 
DROP TABLE Angemeldet CASCADE CONSTRAINTS;
DROP SEQUENCE Proj_Seq;
DROP SEQUENCE Grup_Seq;

-- 2 Sequenzen fÃ¼r die kÃ¼nstlichen PKs 
-- der beiden Tabellen Projekte und Gruppen 
CREATE SEQUENCE Proj_Seq START WITH 1 INCREMENT BY 1;
CREATE SEQUENCE Grup_Seq START WITH 1 INCREMENT BY 1;
drop sequence proj_seqq;
-- Dieses IDENTITY-Feature ist eine Analogie zur AUTOINCREMENT-Spalte bei MySQL
-- ALWAYS besagt, dass die ID bei jedem INSERT generiert wird, egal, ob ein Wert
-- an der Stelle Ã¼bergeben wird oder nicht, somit kann die Angabe eines Wertes
-- fÃ¼r diese Spalte beim INSERT entfallen.
-- Der PrimÃ¤rschlÃ¼ssel hat hier mal einen sprechenden Namen bekommen
CREATE TABLE Studenten (
 StudID               INTEGER   	GENERATED ALWAYS AS IDENTITY
                                 	CONSTRAINT StudPK PRIMARY KEY ,
 Nachname             VARCHAR2(30)	NOT NULL ,
 Vorname              VARCHAR2(30)	NOT NULL ,
 Email                VARCHAR2(50)	NOT NULL 
                      	CONSTRAINT emailSyntax  
                         CHECK  (email LIKE '%@%.__' OR email LIKE '%@%.___') 
                         INITIALLY DEFERRED, 
 Studiengang          VARCHAR2(20) 	NULL ,
 Matrikelnummer       NUMBER(10)   	NOT NULL );



select nachname, vorname, matrikelnummer, studiengang, kennung, bezeichnung, semester, fach
from studenten s join angemeldet a on s.studid=a.studid 
join gruppen g on a.grupid = g.grupid
join projekte p on g.projid = p.projid
where semester in ('WS2020/21','SS2021');

select nachname, vorname
from personal p join projekte po on p.persid= po.prof_persid
where semester = 'SS2020'
group by nachname, vorname
having count(*) = (select count(*) from projekte where semester = 'SS2020');

select nachname, vorname, matrikelnummer
from studenten s
where studid not in (select studid from angemeldet)
order by matrikelnummer desc;

select nachname, vorname, matrikelnummer
from studenten s
where not exists( select s.studid from angemeldet a where s.studid=a.studid)
order by matrikelnummer desc;

select nachname, vorname, matrikelnummer, count(*) anzahl_anmeldungen
from studenten natural join angemeldet natural join gruppen natural join projekte
where studiengang in ('WI','ITM')
group by nachname, vorname, matrikelnummer
having count(*) between 2 and 5
order by anzahl_anmeldungen desc;

select nachname, vorname, matrikelnummer, count(*) anzahl_anmeldungen, semester
from studenten natural join angemeldet natural join gruppen natural join projekte
where studiengang in ('WI', 'ITM')
group by nachname, vorname, matrikelnummer, semester
having count(*) >= 2;



select nachname, vorname, matrikelnummer, count(*), semester
from studenten s
join angemeldet a on s.studid = a.studid
join gruppen g on a.grupid=g.grupid
join projekte p on g.projid= p.projid
where studiengang in ('WI','ITM')
group by nachname, vorname, matrikelnummer, semester
having count(*) >=2;

select distinct nachname, vorname
from Personal p JOIN projekte po ON p.persid=po.prof_persid
where semester in ('SS2020') AND typ in ('P');

select nachname, vorname 
from personal p join projekte po on p.persid=po.prof_persid
where semester in ('SS2020') and typ = ('P')
group by nachname, vorname
having count(*) = (Select count(*) from projekte where semester = 'SS2020');


select s.nachname, s.vorname, s.matrikelnummer, p.email, p.von, p.bis
from studenten s 
left outer join personal p on s.Email=p.Email 
order by nachname asc, von desc;

delete from projekte where prof.persid=1;

CREATE TABLE Personal (
 PersID               INTEGER      GENERATED ALWAYS AS IDENTITY 
                                  CONSTRAINT PersPK PRIMARY KEY,
 Nachname             VARCHAR2(30) NOT NULL ,
 Vorname              VARCHAR2(30) NOT NULL ,
 Email                VARCHAR2(50) NOT NULL ,
 Telefonnr            VARCHAR2(15) NULL ,
 Raum                 VARCHAR2(5)  NULL ,
-- nur vier zulÃ¤ssige Werte beim Typ
-- alternativ mit LOWER
 Typ                  CHAR(1)      NOT NULL 
                      CONSTRAINT PersTypChk 
                           CHECK (UPPER(typ) IN  ('W', 'P', 'S', 'V') ) 
                           INITIALLY IMMEDIATE);

INSERT INTO Projekte ( PROJID, BEZEICHNUNG, SEMESTER, MAXGGROESse, fach, wma_persid, prof_persid, freigeschaltet)
        VALUES ( Proj_Seq.NEXTVAL, 'dbs', 5, 5, 'DBS1', 3, 10, to_date('01.01.2020'));

INSERT INTO Projekte VALUES (proj_seq.NEXTVAL, 'Oracle-Praktikumsprojekt',
'SS2017', 5, 'DBS-2', 1, 33, TO_DATE ('15.04.2017', 'DD.MM.RRRR')); 

--zum droppen von constraints
--ALTER TABLE Personal DROP CONSTRAINT persTypChk;


UPDATE Projekte SET Prof_Persid = 33 WHERE ProjID = 1;


UPDATE Projekte SET prof_persid = 30 WHERE projid=55;
ROLLBACK;
SELECT * FROM PROJEKTE;

select projid, sum(maxggroesse)
from projekte p
where semester = 'SS2021'
group by projid;




UPDATE Studenten
SET Email = 'as@s.ssdasds'
WHERE studID = 1;
COMMIT;
ROLLBACK;
SELECT * FROM PERSONAL;

CREATE TABLE Projekte (
ProjID	INTEGER  CONSTRAINT ProjPK PRIMARY KEY, 
Bezeichnung	VARCHAR2(30) NOT NULL ,
Semester	VARCHAR2(10) NOT NULL ,
maxGGroesse	INTEGER	NULL ,
Fach	VARCHAR2(20) NULL ,
WMA_PersID	INTEGER	NOT NULL ,
Prof_PersID	INTEGER	NULL ,
Freigeschaltet	DATE	NULL   ) ;



INSERT INTO Projekte ( ProjID, bezeichnung, semester, maxggroesse, fach, wma_persid, prof_persid, freigeschaltet)
        VALUES( Proj_Seq.NEXTVAL, 'DBS2', 1, 5, 'DBS', 1, 30, to_date ('01.01.2020', 'dd.mm.rrrr'));

    
UPDATE Projekte p
SET p.prof_persid = 30
WHERE ProjID =1;


UPDATE Gruppen
SET projid = 100
WHERE GrupID=1;

ROLLBACK;

DELETE FROM Projekte WHERE persID=1;

SELECT* FROM Projekte;
ROLLBACK;



DECLARE 
    projID INTEGER = 3;
    result_sum INTEGER;

BEGIN
        result_sum = projid*0,15
        dbms_output.put_line('VALUE OF RESULT_SUM' || result_sum);
        
        END;

CREATE TABLE Gruppen (
GrupID	INTEGER	PRIMARY KEY,
Kennung	VARCHAR2(10) NOT NULL ,
ProjID	INTEGER	NOT NULL ,
PersID	INTEGER	NOT NULL  );

-- Mit diesem zusammengesetzten PrimÃ¤rschlÃ¼ssel realisiert diese
-- Zuordnungstabelle ein ERD mit zwei identifizierenden 1:n-Beziehungen.
CREATE TABLE Angemeldet (
StudID	INTEGER NOT NULL ,
GrupID	INTEGER NOT NULL ,
CONSTRAINT PKAngemeldet PRIMARY KEY (StudID,GrupID) );

/* Alternativ: Diese Zuordnungstabelle mit einem eigenen kÃ¼nstlichen PrimÃ¤r- schlÃ¼ssel ergibt sich dann mit zwei nicht-identifizierenden 1:n-Beziehungen. CREATE TABLE Angemeldet (
AngID	INTEGER PRIMARY KEY,
StudID	INTEGER NOT NULL ,
GrupID	INTEGER NOT NULL );
*/

-- 2 FKs vom Projekt zum Personal
ALTER TABLE Projekte ADD (CONSTRAINT FK_Proj_PersProf
FOREIGN KEY (Prof_PersID) REFERENCES Personal (PersID));
ALTER TABLE Projekte ADD (CONSTRAINT FK_Proj_PersWMA
FOREIGN KEY (WMA_PersID) REFERENCES Personal (PersID));
--
-- 1 FK von der Gruppe zum Personal und 1 FK zum Projekt
ALTER TABLE Gruppen ADD (CONSTRAINT FK_Grup_Pers
FOREIGN KEY (PersID) REFERENCES Personal (PersID));
ALTER TABLE Gruppen ADD (CONSTRAINT FK_Grup_Proj
FOREIGN KEY (ProjID) REFERENCES Projekte (ProjID));
--
-- Zuordnungstabelle, Name ist freiwÃ¤hlbar
-- mit 2 FKs zu dem Master-Tabellen Studenten und Gruppen
ALTER TABLE Angemeldet ADD (CONSTRAINT FK_Ang_Grup
FOREIGN KEY (GrupID) REFERENCES Gruppen (GrupID));
ALTER TABLE Angemeldet ADD (CONSTRAINT FK_Ang_Stud
FOREIGN KEY (StudID) REFERENCES Studenten (StudID));

-- Wenn die Zuordnungstabelle Angemeldet ohne eigenen kÃ¼nstlichen
-- PrimÃ¤rschlÃ¼ssel definiert ist und nur aus den beiden Spalten GrupID und 
-- StudID besteht, dann wird fÃ¼r die Tabelle auch keine Sequenz/Identity
-- Colum benÃ¶tigt. 
-- Anders sieht das aus, wenn ein ANGID-Spalte als kÃ¼nstlicher 
-- PrimÃ¤rschlÃ¼ssel angelegt wurde.   

------
------
------

------------------------------------------------------------------------------------------------------------------------
CREATE TABLE Angestellte3 (
a_id INTEGER PRIMARY KEY,
vorname VARCHAR2(10),
nachname VARCHAR(10),
Eintrittsdatum DATE,
gehalt NUMBER,
geschlecht CHAR,
abt_id INTEGER
);
ALTER TABLE Angestellte3 ADD(gesamt_gehalt NUMBER);
ALTER TABLE Angestellte3 ADD(CONSTRAINT abt_id_fk FOREIGN KEY (abt_id) REFERENCES abteilungen3(abt_id));

CREATE TABLE abteilungen3 (
abt_id INTEGER  PRIMARY KEY,
gehalt NUMBER,
abteilung_name VARCHAR2(20),
a_id INTEGER
);

ALTER TABLE abteilungen3 ADD (CONSTRAINT a_id_fks FOREIGN KEY (a_id) REFERENCES Angestellte3(a_id));

CREATE TABLE Lager3 (
lager_id INTEGER PRIMARY KEY,
produkt VARCHAR2(20),
bestand NUMBER);

CREATE TABLE teile3 (
teile_id INTEGER PRIMARY KEY,
produkt VARCHAR2(20),
bestand NUMBER);

CREATE TABLE Lagerarchiv3 (
arch_lager_id INTEGER PRIMARY KEY,
arch_produkt VARCHAR2(20),
arch_bestand NUMBER
);

CREATE VIEW  Lager3_view AS
SELECT lager_id,produkt,bestand
FROM lager3;

SELECT * FROM lager3_view;

CREATE SEQUENCE arch_lager_id_seq START WITH 1 INCREMENT BY 1;

DROP TABLE abteilungen3 CASCADE CONSTRAINTS;
DROP TABLE angestellte3 CASCADE CONSTRAINTS;
DROP TABLE lager3 CASCADE CONSTRAINTS;
DROP TABLE teile3 CASCADE CONSTRAINTS;
DROP TABLE lagerarchiv3 CASCADE CONSTRAINTS;
DROP SEQUENCE teile_seq;
DROP SEQUENCE a_seq;
DROP SEQUENCE abt_id_seq;
DROP SEQUENCE lager_seq;
DROP SEQUENCE arch_lager_id_seq;

SELECT * FROM angestellte3;
SELECT * FROM abteilungen3;
SELECT * FROM lager3;
SELECT * FROM teile3;

CREATE SEQUENCE a_seq START WITH 1 INCREMENT BY 1;
INSERT INTO Angestellte3 (a_id, vorname, nachname, Eintrittsdatum, gehalt, geschlecht)
    VALUES(a_seq.NEXTVAL,'Markus','Stift', to_date('01.01.1994'), 40000, 'm');
INSERT INTO Angestellte3 (a_id, vorname, nachname, Eintrittsdatum, gehalt, geschlecht)
    VALUES(a_seq.NEXTVAL,'Kuskus','Figar', to_date('01.01.1995'), 50000, '');
INSERT INTO Angestellte3 (a_id, vorname, nachname, Eintrittsdatum, gehalt, geschlecht)
    VALUES(a_seq.NEXTVAL,'Adia','Nadia', to_date('01.01.1996'), 25000, 'w');
INSERT INTO Angestellte3 (a_id, vorname, nachname, Eintrittsdatum, gehalt, geschlecht)
    VALUES(a_seq.NEXTVAL,'Git','Neras', to_date('01.01.1997'), 35500, 'w');
INSERT INTO Angestellte3 (a_id, vorname, nachname, Eintrittsdatum, gehalt, geschlecht)
    VALUES(a_seq.NEXTVAL,'Manish','Sharma', to_date('01.01.1997'), 49500, 'm');

CREATE SEQUENCE abt_id_seq START WITH 1 INCREMENT BY 1;
INSERT INTO abteilungen3 (abt_id,gehalt, abteilung_name, a_id)
    VALUES(abt_id_seq.NEXTVAL,40000, 'Marketing',1);
INSERT INTO abteilungen3 (abt_id, gehalt, abteilung_name, a_id)
    VALUES(abt_id_seq.NEXTVAL,50000,'IT-Consulting',2);
INSERT INTO abteilungen3 (abt_id,gehalt, abteilung_name, a_id)
    VALUES(abt_id_seq.NEXTVAL,25000,'Sales',3);


CREATE SEQUENCE lager_seq START WITH 1 INCREMENT BY 1;
INSERT INTO Lager3 ( lager_id, produkt, bestand)
    VALUES(lager_seq.NEXTVAL, 'Schrauben', 10000);
INSERT INTO Lager3 ( lager_id, produkt, bestand)
    VALUES(lager_seq.NEXTVAL, 'Hammer', 1000);
INSERT INTO Lager3 ( lager_id, produkt, bestand)
    VALUES(lager_seq.NEXTVAL, 'Nagel', 200000);
INSERT INTO Lager3 ( lager_id, produkt, bestand)
    VALUES(lager_seq.NEXTVAL, 'DÃ¼bel', 50000);
    
CREATE SEQUENCE teile_seq START WITH 1 INCREMENT BY 1;
INSERT INTO teile3 ( teile_id, produkt, bestand)
    VALUES(teile_seq.NEXTVAL, 'Schrauben', 10000);
INSERT INTO teile3 ( teile_id, produkt, bestand)
    VALUES(teile_seq.NEXTVAL, 'Hammer', 1000);
INSERT INTO teile3 ( teile_id, produkt, bestand)
    VALUES(teile_seq.NEXTVAL, 'Nagel', 200000);
INSERT INTO teile3 ( teile_id, produkt, bestand)
    VALUES(teile_seq.NEXTVAL, 'DÃ¼bel', 50000);

rollback;
-----------------------------------------------------------------------------------------------------------------

CREATE OR REPLACE PROCEDURE jahre
IS
jahre_ang VARCHAR2(10);
BEGIN
SELECT vorname INTO jahre_ang FROM Angestellte3 WHERE Eintrittsdatum < TO_DATE ('01.01.1995');
dbms_output.put_line('Angestellte: ' || jahre_ang);
END;

EXECUTE jahre;

select * from angestellte3;

DROP TABLE angestellte3;
DROP SEQUENCE a_seq;



---------------------------------------------------------------------------------------------------------

CREATE OR REPLACE PROCEDURE Nachnamen
IS
c_nachname VARCHAR2(10);
indexx INTEGER := 0;

CURSOR c_fetcher IS
SELECT nachname FROM angestellte3;

BEGIN

OPEN c_fetcher;

WHILE (indexx < 1) 
    LOOP
        dbms_output.put_line('Nachname:');
        indexx := indexx+1;
    END LOOP;
    
    LOOP
        FETCH c_fetcher INTO c_nachname;
        EXIT WHEN c_fetcher%NOTFOUND;
        dbms_output.put_line(c_nachname);
    END LOOP;
CLOSE c_fetcher;
END;

SET SERVEROUTPUT ON;
EXECUTE Nachnamen;

----------------------------------------------------------------------------------------

CREATE OR REPLACE PROCEDURE transform_name(vorname IN VARCHAR2, vorname_out OUT VARCHAR2, nachname IN VARCHAR2, nachname_out OUT VARCHAR2)
IS
BEGIN
vorname_out := UPPER(vorname);
nachname_out := UPPER(nachname);
END;

DECLARE
a VARCHAR2(20);
b VARCHAR2(20);
BEGIN
transform_name('noel',a,'kÃ¶roglu',b);
dbms_output.put_line(a ||', '||b);
END;

-----------------------------------------------------------------------------------------

CREATE OR REPLACE PROCEDURE parameterss (params IN VARCHAR2, param_Out OUT VARCHAR2)
IS
BEGIN
dbms_output.put_line('Ausgabe: ' ||params);
END;


DECLARE
inpp VARCHAR2(30);
BEGIN
parameterss('THESE HOES AINT LOYAL',inpp);
dbms_output.put_line(inpp);
END;

------------------------------------------------------------------------------------------

CREATE OR REPLACE FUNCTION gehaltsklasse
(a_id_geh NUMBER) RETURN NUMBER
IS
geh_klasse_max NUMBER := 50000;
geh_klasse_min NUMBER := 10000;
akt_geh_klasse NUMBER;
a_number NUMBER;
BEGIN
SELECT gehalt INTO akt_geh_klasse FROM angestellte3 WHERE a_id = a_id_geh;
CASE a_id_geh = a_id_geh
    WHEN akt_geh_klasse  >= 35000 AND akt_geh_klasse <= 50000
        THEN dbms_output.put_line('Gehaltsklasse im oberen Bereich! Das Gehalt betrÃ¤gt: ' || akt_geh_klasse || ' Euro.|');
    WHEN akt_geh_klasse >= 10000 AND akt_geh_klasse <= 35000
        THEN dbms_output.put_line('Gehalsklasse im statistisch durchschnittlichen Bereich. Das Gehalt betrÃ¤gt: '  || akt_geh_klasse || ' Euro.');
END CASE;
RETURN a_number;
END;

SET SERVEROUTPUT ON;
BEGIN
dbms_output.put_line(gehaltsklasse(3));
END;

--------------------------------------------------------------------------------------------------------

--NOT FINISHED

CREATE OR REPLACE FUNCTION anrede_bestimmen (geschlecht1 CHAR DEFAULT NULL, name1 VARCHAR2 DEFAULT NULL)
RETURN new_type AS new_type_variable;
IS
c_nachname VARCHAR2(10);
c_geschlecht VARCHAR2(10);
nachname_1 VARCHAR2(10);
geschlecht_1 VARCHAR2(10);
b VARCHAR2(10);
c VARCHAR2(10);
indexx INTEGER;


CURSOR c_fetcher IS
SELECT nachname, geschlecht FROM angestellte3;

BEGIN
OPEN c_fetcher;

WHILE (indexx < 1) 
    LOOP
    geschlecht_1 := geschlecht1;
    nachname_1 := name1;
    
    IF (geschlecht_1 = 'm') AND (nachname_1 = 'Stift') THEN
        dbms_output.put_line('Sehr geehrter Herr ' || nachname_1);
    
        LOOP
        FETCH c_fetcher INTO c_nachname, c_geschlecht;
        EXIT WHEN c_fetcher%NOTFOUND;
                indexx := indexx+1;
                    SELECT c_fetcher INTO new_type_variable.res from dual;


        END LOOP;
        
    ELSIF (c_geschlecht = 'w') THEN
        dbms_output.put_line('Sehr geehrte Frau ' || c_nachname);
                indexx := indexx+1;
                LOOP
        FETCH c_fetcher INTO c_nachname, c_geschlecht;
        EXIT WHEN c_fetcher%NOTFOUND;
        SELECT c_fetcher INTO new_type_variable.res from dual;
        END LOOP;
                
    ELSIF (c_geschlecht = ' ') THEN
        dbms_output.put_line('Sehr geehrte Damen und Herren  ');
                indexx := indexx+1;
                LOOP
        FETCH c_fetcher INTO c_nachname, c_geschlecht;
        EXIT WHEN c_fetcher%NOTFOUND;
        END LOOP;
                
    ELSE dbms_output.put_line('Sehr geehrte Damen und Herren ');
            indexx := indexx+1;
            
    CLOSE c_fetcher;
    END IF;
    END LOOP;
    
    RETURN new_type_variable;
END;


SET SERVEROUTPUT ON;

BEGIN
dbms_output.put_line(anrede_bestimmen('m', 'Stift'));
END;

------------------------------------------------------------------------------------------------------
--TRIGGER
SET SERVEROUTPUT ON;

CREATE OR REPLACE TRIGGER trg_budget_check
BEFORE INSERT ON angestellte3
FOR EACH ROW
DECLARE 
gesamtbudget NUMBER := 100000;
aktuell_gesamt_gehalt NUMBER;
BEGIN
SELECT SUM(a.gehalt) INTO aktuell_gesamt_gehalt FROM angestellte3 a;
IF ( gesamtbudget < aktuell_gesamt_gehalt)
    THEN dbms_output.put_line( 'Das aktuelle Budget fÃ¼r die GehÃ¤lter wurde Ã¼berschritten! Alle GehÃ¤tler werden auf 5000 Euro gekÃ¼rzt!');
UPDATE angestellte3 a
SET a.gehalt = 5000;

ELSIF ( gesamtbudget = aktuell_gesamt_gehalt)
    THEN dbms_output.put_line('alles ok');
ELSIF (gesamtbudget > aktuell_gesamt_gehalt)
    THEN dbms_output.put_line('das streben wir an!');
ELSE
    DBMS_OUTPUT.PUT_LINE('falsche eingabe');
END IF;
END;

DROP TRIGGER trg_budget_check;
DROP TRIGGER neues_gesamt_gehalt;


SELECT SUM(gehalt) from angestellte3;

DELETE FROM angestellte3 WHERE a_id=25;
UPDATE angestellte3 SET gesamt_gehalt = ( SELECT SUM(gehalt) FROM angestellte3);

INSERT INTO Angestellte3 (a_id, vorname, nachname, Eintrittsdatum, gehalt, geschlecht)
    VALUES(a_seq.NEXTVAL,'Refust','Vogottin', to_date('01.01.1981'), 5000, 'm');
    
SELECT * FROM angestellte3;
rollback;
--------------------------------------------------------------------------------------------------------

CREATE OR REPLACE TRIGGER gehalt_kontrolle
BEFORE UPDATE OF gehalt ON angestellte3
FOR EACH ROW
BEGIN
IF :NEW.gehalt < :OLD.gehalt
    THEN RAISE_APPLICATION_ERROR(-029387, 'Neues Gehalt darf nicht geringer als altes sein!');
END IF;
END;


UPDATE angestellte3 SET gehalt=1100 WHERE a_id=1;
DROP TRIGGER gehalt_kontrolle;
SELECT*FROM angestellte3;
--------------------------------------------------------------------------------------------------------------------

SET SERVEROUTPUT ON;
CREATE OR REPLACE TRIGGER trg_leiter_gehalt
AFTER INSERT OR UPDATE ON abteilungen3
FOR EACH ROW
WHEN (new.a_id>0)
DECLARE
Gehaltsgruppe3 NUMBER := 40001;
Abteilungsleiter INTEGER;
gehalt_akt NUMBER;
mindestgehalt NUMBER := 40001;
BEGIN
abteilungsleiter := :new.a_id;          --verweist neue a_id auf abteilungsleiter
IF (:new.gehalt > Gehaltsgruppe3)
    THEN 
        dbms_output.put_line('Gehalt ist im erwarteten Bereich');
        gehalt_akt := :new.gehalt;
ELSIF (:new.gehalt < Gehaltsgruppe3)   
    THEN 
        dbms_output.put_line('Gehalt zu gering');
        dbms_output.put_line('Das aktuelle gehtalt ' || gehalt_akt || ' soll auf 40001 erhÃ¶ht werden.');
ELSE
    dbms_output.put_line('ok');
END IF;
END;


UPDATE abteilungen3 SET gehalt=4000 WHERE a_id=1;
SELECT * FROM abteilungen3;

DROP TRIGGER trg_leiter_gehalt;
DROP TRIGGER test1;

rollback;

-------------------------------------------------------------------------------------------------------

CREATE OR REPLACE TRIGGER trg_bestand_pruefen
AFTER INSERT OR DELETE OR UPDATE OF bestand ON Lager3
FOR EACH ROW
DECLARE
akt_bestand NUMBER;
id_neu INTEGER;
BEGIN

IF (:new.bestand <> :old.bestand)
    THEN 
    akt_bestand := :new.bestand;
    id_neu := :new.lager_id;
    UPDATE teile3 t
    SET bestand = akt_bestand
    WHERE t.teile_id = id_neu;
END IF;
END;


UPDATE lager3 SET bestand = 1000 WHERE Produkt ='DÃ¼bel';

SELECT * FROM lager3;
SELECT * FROM teile3;
DROP TRIGGER TRG_BESTAND_PRUEFEN;
----------------------------------------------------------------------------------------------------------------------

SET SERVEROUTPUT ON;

CREATE OR REPLACE TRIGGER trg_erh_gehalt
BEFORE UPDATE OF gehalt ON angestellte3
FOR EACH ROW
DECLARE
gehalt_aktuell NUMBER;
gehalt_mit_erhoehung NUMBER;
zu_niedrig_gehalt NUMBER;
gehalt_mit_korrekter_erhoehung NUMBER;
BEGIN
gehalt_aktuell := :NEW.gehalt;
zu_niedrig_gehalt := :OLD.gehalt;
gehalt_mit_korrekter_erhoehung := zu_niedrig_gehalt + :OLD.gehalt * 0.1;
    
IF (:NEW.gehalt > :OLD.gehalt)
    THEN
        IF(:NEW.gehalt < gehalt_mit_korrekter_erhoehung)
                THEN
                    dbms_output.put_line('Ihr neues Gehalt: ' || gehalt_mit_korrekter_erhoehung);
                ELSIF(gehalt_aktuell > gehalt_mit_korrekter_erhoehung)
                    THEN
                        dbms_output.put_line('Neues gehalt: ' || gehalt_mit_korrekter_erhoehung);
                ELSE 
                        dbms_output.put_line('Neues gehalt: ' || gehalt_aktuell);

        END IF;
        
ELSIF (:NEW.gehalt < :OLD.gehalt)
    THEN
        dbms_output.put_line('Ihr neues Gehalt: ' || gehalt_mit_korrekter_erhoehung);
        
ELSIF (:NEW.gehalt = :OLD.gehalt)
     THEN 
        dbms_output.put_line('Ihr neues Gehalt: ' || gehalt_mit_korrekter_erhoehung);
ELSE
    RAISE_APPLICATION_ERROR(229384, 'Falsche Eingabe');
END IF;
END;

UPDATE angestellte3 SET gehalt = 40000 WHERE a_id = 1;
SELECT * FROM angestellte3;
DROP TRIGGER trg_erh_gehalt;
rollback;
------------------------------------------------------------------------------------------------------------------------------
SET SERVEROUTPUT ON;
CREATE OR REPLACE TRIGGER trg_pos_archiv
AFTER DELETE ON Lager3
FOR EACH ROW
DECLARE
looper INTEGER := 0;
counts INTEGER;
BEGIN
--SELECT SUM(COUNT(*)) INTO counts FROM lager3 group by lager_id having count(*) > 0;
INSERT INTO lagerarchiv3 (arch_lager_id, arch_produkt, arch_bestand)
    VALUES (arch_lager_id_seq.NEXTVAL, :OLD.produkt, :OLD.bestand);
END;

--SELECT SUM(COUNT(*)) as c FROM lager3 group by lager_id having count(*) >0;

DELETE FROM lager3 WHERE lager_id=2;
SELECT * FROM lager3;
SELECT * FROM lagerarchiv3;
rollback;

-------------------------------------------------------------------------------------------------------------------------------
SET SERVEROUTPUT ON;
CREATE OR REPLACE TRIGGER trg_geh_prot
AFTER UPDATE OR DELETE OF gehalt ON angestellte3
FOR EACH ROW
DECLARE
a_id1 NUMBER;
GehaltsverÃ¤nderung NUMBER;
BEGIN
GehaltsverÃ¤nderung := :NEW.gehalt - :OLD.gehalt;
a_id1:= :NEW.a_id;
IF (:OLD.GEHALT <> :NEW.gehalt)
    THEN dbms_output.put_line(to_char(sysdate,'DD-MON-YYYY'));
    dbms_output.put_line('Angestellten_Kennung: ' || a_id1);
    dbms_output.put_line('GehaltsverÃ¤nderungssumme: ' || GehaltsverÃ¤nderung);
END IF;
END;

update ANGESTELLTE3 set gehalt = 1000 WHERE a_id = 1;

DROP TRIGGER trg_geh_prot;

----------------------------------------------------------------------------------------------------------------------------

CREATE OR REPLACE TRIGGER trg_geh_check
AFTER UPDATE OF gehalt ON angestellte3
FOR EACH ROW
DECLARE
BEGIN
IF (:NEW.gehalt < :OLD.gehalt)
    THEN RAISE_APPLICATION_ERROR ( -20001, 'GehÃ¤lter dÃ¼rfen nicht sinken!');
END IF;
END;

SELECT * FROM angestellte3;
UPDATE angestellte3 SET gehalt = 1000 WHERE a_id = 1;

--------------------------------------------------------------------------------------------------------------------------

CREATE TABLE Firma (
name VARCHAR2(20),
branche VARCHAR2(20),
a_id INTEGER
);
ALTER TABLE FIRMA ADD (CONSTRAINT a_id_fk FOREIGN KEY (a_id) REFERENCES angestellte3(a_id));



CREATE VIEW vw_firma AS
SELECT f.name, f.branche, a.a_id, a.nachname FROM Firma f
JOIN angestellte3 a ON f.a_id=a.a_id;



CREATE OR REPLACE TRIGGER trg_view_firma
INSTEAD OF INSERT ON vw_firma
FOR EACH ROW
BEGIN
INSERT INTO FIRMA (name, branche, a_id)
    VALUES(:NEW.name, :NEW.branche, :NEW.a_id);
END;


INSERT INTO vw_Firma (name, branche, a_id)    -- Kann nicht in VIEW eingefÃ¼gt werden, deswegen der INSTEAD OF TRIGGER
    VALUES ('Skyscrapers', 'Immobilien', 2);



DELETE FROM FIRMA WHERE name = 'Kronoss';

SELECT * FROM Firma;
SELECT * FROM vw_firma;
DROP TABLE Firma;
DROP VIEW vw_FIRMA;
DROP TRIGGER trg_view_firma;
rollback;



